<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Chronos Control Panel (Mobile ‚Ä¢ Sci-Fi Blue)</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            ink: { 900:"#0B0C10", 800:"#0F1117", 700:"#12141D", 600:"#141726", 500:"#171A2B" },
            accent: { violet:"#7C5CFF", indigo:"#6366F1", blue:"#3B82F6", green:"#39D98A", magenta:"#FF5470", amber:"#FBBF24" }
          },
          boxShadow: {
            glow: "0 10px 30px rgba(99,102,241,.35)",
            soft: "0 10px 25px rgba(0,0,0,.35)"
          },
          borderRadius: { "2xl":"1.25rem" }
        }
      }
    }
  </script>

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">

  <style>
    html, body { height: 100%; }
    body { font-family: Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    .glass { backdrop-filter: saturate(160%) blur(8px); -webkit-backdrop-filter: saturate(160%) blur(8px); }

    /* Card styling */
    .os-card { position: relative; padding: 1px; border-radius: 1rem; transition: transform .25s ease, filter .25s ease; }
    .os-card:hover { transform: translateY(-2px); filter: brightness(1.02); }
    .os-card-inner { border-radius: inherit; background: rgba(20, 23, 38, .66); border: 1px solid rgba(255,255,255,.08); padding: 1rem; }
    .os-card--fresh    { background: linear-gradient(135deg, rgba(59,130,246,.28), rgba(124,92,255,.28)); box-shadow: 0 10px 30px rgba(59,130,246,.20); }
    .os-card--expiring { background: linear-gradient(135deg, rgba(251,191,36,.25), rgba(245,158,11,.25)); box-shadow: 0 10px 30px rgba(251,191,36,.15); }
    .os-card--expired  { background: linear-gradient(135deg, rgba(255,84,112,.25), rgba(251,113,133,.25)); box-shadow: 0 10px 30px rgba(255,84,112,.15); }

    .chip { font-size: 10px; line-height: 1; padding: .25rem .5rem; border-radius: .6rem; border: 1px solid rgba(255,255,255,.12); }
    .status-panel { background: linear-gradient(135deg, rgba(59,130,246,.14), rgba(124,92,255,.12)); border: 1px solid rgba(99,102,241,.32); }

    /* Mobile-first chart heights */
    .chart-wrap { height: 220px; }
    .chart-mini { height: 160px; }
    @media (min-width: 640px) { .chart-wrap { height: 260px; } .chart-mini { height: 180px; } }
  </style>
</head>

<body class="bg-ink-900 text-white antialiased">
  <!-- Background accents (bluer) -->
  <div class="pointer-events-none fixed inset-0 -z-10">
    <div class="absolute -top-28 -right-28 h-80 w-80 rounded-full bg-accent-blue/20 blur-3xl" style="--tw-bg-opacity:1;background-color:rgba(59,130,246,0.2)"></div>
    <div class="absolute top-1/3 -left-28 h-72 w-72 rounded-full bg-accent-violet/20 blur-3xl"></div>
    <div class="absolute bottom-10 left-1/4 h-64 w-64 rounded-full" style="background: radial-gradient(closest-side, rgba(99,102,241,.22), rgba(0,0,0,0)); filter: blur(18px);"></div>
  </div>

  <!-- Header -->
  <header class="max-w-screen-md mx-auto px-4 pt-5">
    <div class="flex items-center justify-between gap-3">
      <div class="flex items-center gap-3 min-w-0">
        <div class="h-12 w-12 rounded-2xl bg-gradient-to-br from-accent-blue to-accent-violet shadow-glow grid place-items-center">
          <svg class="h-6 w-6 text-white drop-shadow" viewBox="0 0 24 24" fill="currentColor" aria-hidden="true">
            <path d="M12 2a1 1 0 0 1 1 1v2.07a7.002 7.002 0 0 1 5.93 5.93H21a1 1 0 1 1 0 2h-2.07a7.002 7.002 0 0 1-5.93 5.93V21a1 1 0 1 1-2 0v-2.07A7.002 7.002 0 0 1 5.07 13H3a1 1 0 1 1 0-2h2.07A7.002 7.002 0 0 1 11 5.07V3a1 1 0 0 1 1-1zM12 7a5 5 0 1 0 .001 10.001A5 5 0 0 0 12 7z"/>
          </svg>
        </div>
        <div class="min-w-0">
          <h1 class="text-xl font-extrabold tracking-tight leading-tight truncate">
            Chrona<span class="text-accent-blue" style="color:#3B82F6">Core</span> ‚Äî Time Machine Control
          </h1>
          <p class="text-xs text-white/70 leading-tight truncate">Quantum routing ‚Ä¢ Flux regulation ‚Ä¢ Causality guards</p>
        </div>
      </div>

      <!-- ONLINE badge -->
      <div class="flex items-center gap-2 rounded-full px-3 py-1.5 border border-accent-blue/30 bg-accent-blue/10 text-accent-blue text-xs shrink-0">
        <span class="h-2 w-2 rounded-full bg-accent-blue animate-pulse"></span>
        Online
      </div>
    </div>
  </header>

  <main class="max-w-screen-md mx-auto px-4 pb-8">
    <!-- Core Status + Primary Graph -->
    <section class="mt-4">
      <div class="glass rounded-2xl border border-white/10 bg-ink-800/60 shadow-soft">
        <div class="p-4 sm:p-5">
          <div class="rounded-xl status-panel p-3">
            <div class="grid grid-cols-3 gap-3">
              <div class="flex flex-col items-center justify-center">
                <p class="text-[11px] text-white/60">Core Stability</p>
                <p id="currentCore" class="text-2xl font-extrabold" style="color:#60A5FA">97%</p>
              </div>
              <div class="flex flex-col items-center justify-center">
                <p class="text-[11px] text-white/60">Temporal Mode</p>
                <p class="text-sm font-semibold" style="color:#7C5CFF">Drift-Lock</p>
              </div>
              <div class="flex flex-col items-center justify-center">
                <p class="text-[11px] text-white/60">Causality</p>
                <p class="text-sm font-semibold text-accent-green">Stable</p>
              </div>
            </div>
          </div>

          <!-- Temporal Flux -->
          <div class="mt-4">
            <div class="flex items-center justify-between">
              <h3 class="text-sm font-semibold">Temporal Flux (24h)</h3>
              <div class="text-[11px] text-white/60">Target 90‚Äì100% ‚Ä¢ Controlled drift</div>
            </div>
            <div class="mt-2 chart-wrap">
              <canvas id="tempChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Action Deck + Stability Pack -->
    <section class="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-4">
      <div class="glass rounded-2xl border border-white/10 bg-ink-800/60 shadow-soft">
        <div class="p-4 sm:p-5">
          <h3 class="text-sm font-semibold mb-3">Control Deck</h3>
          <div class="grid grid-cols-2 gap-2">
            <button class="rounded-xl border border-white/10 bg-white/5 px-3 py-2 text-sm font-semibold hover:bg-white/10 transition">Engage Drift-Lock</button>
            <button class="rounded-xl border border-white/10 bg-white/5 px-3 py-2 text-sm font-semibold hover:bg-white/10 transition">Stabilize Core</button>
            <button class="rounded-xl border border-white/10 bg-white/5 px-3 py-2 text-sm font-semibold hover:bg-white/10 transition">Prime Jump</button>
            <button class="rounded-xl border border-white/10 bg-white/5 px-3 py-2 text-sm font-semibold hover:bg-white/10 transition">Purge Paradox</button>
            <button class="rounded-xl border border-white/10 bg-white/5 px-3 py-2 text-sm font-semibold hover:bg-white/10 transition">Recalibrate Beacons</button>
            <button class="rounded-xl border border-white/10 bg-white/5 px-3 py-2 text-sm font-semibold hover:bg-white/10 transition">Flux Dampeners</button>
          </div>

          <div class="mt-4 grid grid-cols-2 gap-2">
            <label class="flex items-center gap-2 text-xs">
              <input type="checkbox" class="accent-indigo-500" checked> Safety Interlock A
            </label>
            <label class="flex items-center gap-2 text-xs">
              <input type="checkbox" class="accent-indigo-500" checked> Safety Interlock B
            </label>
            <label class="flex items-center gap-2 text-xs col-span-2">
              <input type="checkbox" class="accent-indigo-500"> Permit Experimental Mode
            </label>
          </div>
        </div>
      </div>

      <div class="glass rounded-2xl border border-white/10 bg-ink-800/60 shadow-soft">
        <div class="p-4 sm:p-5">
          <h3 class="text-sm font-semibold">Stability Pack</h3>
          <div class="mt-3 grid grid-cols-3 gap-2 items-center">
            <!-- Ring -->
            <div class="col-span-1">
              <div class="relative w-20 h-20 mx-auto">
                <svg class="w-full h-full" viewBox="0 0 120 120">
                  <circle cx="60" cy="60" r="54" fill="none" stroke="rgba(255,255,255,0.12)" stroke-width="12" />
                  <circle id="freshnessRing" cx="60" cy="60" r="54" fill="none" stroke="url(#freshnessGradient)" stroke-width="12" stroke-dasharray="339.3" stroke-dashoffset="100" stroke-linecap="round" transform="rotate(-90 60 60)" />
                  <defs>
                    <linearGradient id="freshnessGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                      <stop offset="0%" stop-color="#3B82F6" />
                      <stop offset="100%" stop-color="#7C5CFF" />
                    </linearGradient>
                  </defs>
                </svg>
                <div class="absolute inset-0 flex flex-col items-center justify-center">
                  <span id="freshnessPct" class="text-xl font-extrabold">94</span>
                  <span class="text-[11px] text-white/60 font-medium">%</span>
                </div>
              </div>
            </div>

            <!-- Small stats -->
            <div class="col-span-2 grid grid-cols-3 gap-2">
              <div class="rounded-lg border border-white/10 bg-ink-700/50 p-2 text-center">
                <p class="text-[11px] text-white/60">Queue</p>
                <p id="statTotal" class="text-lg font-extrabold">0</p>
              </div>
              <div class="rounded-lg border border-white/10 bg-ink-700/50 p-2 text-center">
                <p class="text-[11px] text-white/60">Stable</p>
                <p id="statFresh" class="text-lg font-extrabold" style="color:#60A5FA">0</p>
              </div>
              <div class="rounded-lg border border-white/10 bg-ink-700/50 p-2 text-center">
                <p class="text-[11px] text-white/60">Closing</p>
                <p id="statExpiring" class="text-lg font-extrabold text-accent-amber">0</p>
              </div>
            </div>
          </div>

          <!-- Jumps -->
          <div class="mt-4">
            <div class="flex items-center justify-between">
              <h3 class="text-sm font-semibold">Jump Attempts (24h)</h3>
              <span class="text-[11px] text-white/60">peaks ‚âà high traffic</span>
            </div>
            <div class="mt-2 chart-mini">
              <canvas id="doorChart"></canvas>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Scheduler -->
    <section class="mt-4">
      <div class="glass rounded-2xl border border-white/10 bg-ink-800/60 shadow-soft">
        <div class="p-4 sm:p-5">
          <h3 class="text-sm font-semibold mb-3">Schedule Jump</h3>
          <div class="grid grid-cols-2 gap-2">
            <input id="foodName" class="col-span-2 rounded-lg border border-white/10 bg-ink-600 px-3 py-2 text-sm placeholder:text-white/40 focus:outline-none focus:ring-2 focus:ring-accent-violet/60" placeholder="Target label (e.g., 'Renaissance ‚Äî Florence')" />
            <select id="foodCategory" class="rounded-lg border border-white/10 bg-ink-600 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-accent-violet/60">
              <option value="ancient">Ancient</option>
              <option value="industrial">Industrial</option>
              <option value="present">Present</option>
              <option value="near-future">Near-Future</option>
              <option value="far-future">Far-Future</option>
              <option value="parallel">Parallel</option>
            </select>
            <input id="expiryDate" type="date" class="rounded-lg border border-white/10 bg-ink-600 px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-accent-violet/60" />
            <div class="col-span-2 grid grid-cols-3 gap-2">
              <input id="yearInput" class="rounded-lg border border-white/10 bg-ink-600 px-3 py-2 text-sm" placeholder="Year" inputmode="numeric" />
              <input id="monthInput" class="rounded-lg border border-white/10 bg-ink-600 px-3 py-2 text-sm" placeholder="Month" inputmode="numeric" />
              <input id="offsetInput" class="rounded-lg border border-white/10 bg-ink-600 px-3 py-2 text-sm" placeholder="Local Offset" />
            </div>
            <button id="addFoodBtn" class="col-span-2 rounded-lg bg-gradient-to-br from-accent-blue to-accent-violet px-3 py-2.5 text-sm font-semibold shadow-glow hover:brightness-105 transition">Queue Jump</button>
            
            <!-- Jump Charge Progress and Button -->
            <div class="col-span-2 mt-3 rounded-xl border border-white/10 bg-ink-700/50 p-3">
              <div class="flex items-center justify-between mb-2">
                <h4 class="text-xs font-semibold">Jump Charge</h4>
                <span id="jumpChargeValue" class="text-xs text-white/60">0%</span>
              </div>
              <div class="h-2 w-full bg-ink-600 rounded-full overflow-hidden">
                <div id="jumpChargeProgress" class="h-full bg-gradient-to-r from-accent-blue to-accent-violet" style="width: 0%"></div>
              </div>
              <button id="jumpNowBtn" class="mt-3 w-full rounded-lg bg-gradient-to-br from-accent-violet to-accent-blue px-3 py-2.5 text-sm font-semibold transition-all duration-300 hover:brightness-110">JUMP NOW</button>
            </div>
          </div>
        </div>
      </div>
    </section>
    
    <!-- Chronon Supply Section -->
    <section class="mt-4">
      <div class="glass rounded-2xl border border-white/10 bg-ink-800/60 shadow-soft">
        <div class="p-4 sm:p-5">
          <div class="flex items-center justify-between">
            <h3 class="text-sm font-semibold">Chronon Supply</h3>
            <span class="text-[11px] text-white/60">Temporal fuel level</span>
          </div>
          <div class="mt-2 chart-mini">
            <canvas id="chrononChart"></canvas>
          </div>
          <div class="mt-2 grid grid-cols-2 gap-2">
            <div class="flex items-center justify-between rounded-lg border border-white/10 bg-ink-700/50 px-3 py-2">
              <span class="text-xs text-white/60">Current:</span>
              <span id="currentChrononLevel" class="text-sm font-bold" style="color:#60A5FA">100%</span>
            </div>
            <div class="flex items-center justify-between rounded-lg border border-white/10 bg-ink-700/50 px-3 py-2">
              <span class="text-xs text-white/60">Burn Rate:</span>
              <span id="chrononBurnRate" class="text-sm font-bold text-accent-amber">12.5% / jump</span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Analytics Row: Battery + Paradox Risk -->
    <section class="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-4">
      <div class="glass rounded-2xl border border-white/10 bg-ink-800/60 shadow-soft">
        <div class="p-4 sm:p-5">
          <div class="flex items-center justify-between">
            <h3 class="text-sm font-semibold">Quantum Battery</h3>
            <span class="text-[11px] text-white/60">Charge vs Reserve</span>
          </div>
          <div class="mt-2 chart-mini">
            <canvas id="batteryChart"></canvas>
          </div>
          <div class="mt-3 grid grid-cols-3 gap-2">
            <button class="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs font-semibold hover:bg-white/10 transition">Boost</button>
            <button class="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs font-semibold hover:bg-white/10 transition">Balance</button>
            <button class="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs font-semibold hover:bg-white/10 transition">Hibernate</button>
          </div>
        </div>
      </div>

      <div class="glass rounded-2xl border border-white/10 bg-ink-800/60 shadow-soft">
        <div class="p-4 sm:p-5">
          <div class="flex items-center justify-between">
            <h3 class="text-sm font-semibold">Paradox Risk (radar)</h3>
            <span class="text-[11px] text-white/60">lower is safer</span>
          </div>
          <div class="mt-2 chart-mini">
            <canvas id="riskChart"></canvas>
          </div>
          <div class="mt-3 grid grid-cols-2 gap-2">
            <button class="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs font-semibold hover:bg-white/10 transition">Auto-Mitigate</button>
            <button class="rounded-lg border border-white/10 bg-white/5 px-3 py-2 text-xs font-semibold hover:bg-white/10 transition">Audit Timeline</button>
          </div>
        </div>
      </div>
    </section>

    <!-- Windows Lists -->
    <section class="mt-4 grid grid-cols-1 sm:grid-cols-2 gap-4">
      <div class="glass rounded-2xl border border-white/10 bg-ink-800/60 shadow-soft">
        <div class="p-4 sm:p-5">
          <div class="flex items-center justify-between gap-2">
            <h2 class="text-sm font-bold" style="color:#60A5FA">Stable Windows</h2>
            <div class="text-[11px] text-white/60">Safest to travel</div>
          </div>
          <div id="freshList" class="mt-3 space-y-3"></div>
        </div>
      </div>

      <div class="glass rounded-2xl border border-white/10 bg-ink-800/60 shadow-soft">
        <div class="p-4 sm:p-5">
          <div class="flex items-center justify-between gap-2">
            <h2 class="text-sm font-bold text-accent-amber">Closing Soon</h2>
            <div class="text-[11px] text-white/60">&lt; 72 hours</div>
          </div>
          <div id="expiringList" class="mt-3 space-y-3"></div>
        </div>
      </div>

      <div class="glass rounded-2xl border border-white/10 bg-ink-800/60 shadow-soft sm:col-span-2">
        <div class="p-4 sm:p-5">
          <div class="flex items-center justify-between gap-2">
            <h2 class="text-sm font-bold text-accent-magenta">Closed Windows</h2>
            <div class="text-[11px] text-white/60">Re-align required</div>
          </div>
          <div id="expiredList" class="mt-3 space-y-3"></div>
        </div>
      </div>
    </section>
  </main>

  <footer class="max-w-screen-md mx-auto px-4 pb-8">
    <div class="flex items-center justify-between text-[11px] text-white/50">
      <span>¬© <span id="year"></span> ChronaCore ‚Äî Demo</span>
      <span>Blue-purple UI ‚Ä¢ Local-first</span>
    </div>
  </footer>

  <script>
    document.getElementById("year").textContent = new Date().getFullYear();

    /* ----------------------------
       Queue (fake data) + Rendering
    -----------------------------*/
    const foodItems = [];

    const foodNameEl = document.getElementById("foodName");
    const foodCategoryEl = document.getElementById("foodCategory");
    const expiryDateEl = document.getElementById("expiryDate");
    const addFoodBtn = document.getElementById("addFoodBtn");

    const statTotal = document.getElementById("statTotal");
    const statFresh = document.getElementById("statFresh");
    const statExpiring = document.getElementById("statExpiring");

    const freshList = document.getElementById("freshList");
    const expiringList = document.getElementById("expiringList");
    const expiredList = document.getElementById("expiredList");

    const defaultDate = new Date(); defaultDate.setDate(defaultDate.getDate() + 7);
    expiryDateEl.value = defaultDate.toISOString().split('T')[0];

    addFoodBtn.addEventListener("click", () => {
      playSound('buttonPress');
      const name = (foodNameEl.value || "").trim();
      const category = foodCategoryEl.value;
      const expiryDate = expiryDateEl.value;
      
      // Check if this is jump initiation
      if (addFoodBtn.textContent === "INITIATE JUMP") {
        // Start jump charge sequence instead of immediately jumping
        startJumpCharge();
        return;
      }
      
      // Regular jump scheduling
      if (!name || !expiryDate) { 
        showNotification("Please enter a destination name and target date", "warning");
        return; 
      }
      
      // Check if year and month are filled
      const yearInput = document.getElementById('yearInput').value;
      const monthInput = document.getElementById('monthInput').value;
      
      if (yearInput || monthInput) {
        // If they provided year/month details, mention them in the notification
        let timeDetails = "";
        if (yearInput) timeDetails += `Year ${yearInput}`;
        if (yearInput && monthInput) timeDetails += ", ";
        if (monthInput) timeDetails += `Month ${monthInput}`;
        
        showNotification(`Added window to ${name} (${timeDetails})`, "info");
      } else {
        showNotification(`Added temporal window: ${name}`, "info");
      }
      
      foodItems.push({ id: Date.now(), name, category, expiryDate, addedDate: todayISO() });
      foodNameEl.value = "";
      expiryDateEl.value = defaultDate.toISOString().split('T')[0];
      document.getElementById('yearInput').value = "";
      document.getElementById('monthInput').value = "";
      document.getElementById('offsetInput').value = "";
      renderFoodItems();
    });

    function todayISO() { return new Date().toISOString().split('T')[0]; }
    function getDateOffset(days) { const d = new Date(); d.setDate(d.getDate() + days); return d.toISOString().split('T')[0]; }

    function foodStatus(expiryDate) {
      const today = new Date(), exp = new Date(expiryDate);
      const diffDays = Math.ceil((exp - today) / 86400000);
      if (diffDays < 0) return "expired";
      if (diffDays <= 3) return "expiring";
      return "fresh";
    }

    function removeItem(id) {
      const idx = foodItems.findIndex(i => i.id === id);
      if (idx >= 0) { foodItems.splice(idx, 1); renderFoodItems(); }
    }

    function renderFoodItems() {
      const fresh    = foodItems.filter(i => foodStatus(i.expiryDate) === "fresh");
      const expiring = foodItems.filter(i => foodStatus(i.expiryDate) === "expiring");
      const expired  = foodItems.filter(i => foodStatus(i.expiryDate) === "expired");

      statTotal.textContent    = foodItems.length;
      statFresh.textContent    = fresh.length;
      statExpiring.textContent = expiring.length;

      updateStabilityRing(fresh.length, expiring.length, expired.length);

      renderList(fresh, freshList, "fresh");
      renderList(expiring, expiringList, "expiring");
      renderList(expired, expiredList, "expired");
    }

    function renderList(items, container, status) {
      if (!items.length) { container.innerHTML = `<div class="text-sm text-white/50 border border-white/10 rounded-xl p-4">No entries</div>`; return; }
      container.innerHTML = "";

      for (const item of items) {
        const chipClass = status === "expired"
          ? "bg-accent-magenta/15 border-accent-magenta/40 text-accent-magenta"
          : status === "expiring"
          ? "bg-accent-amber/15 border-accent-amber/40 text-accent-amber"
          : "bg-[rgba(59,130,246,.15)] border border-[rgba(59,130,246,.4)] text-[rgba(96,165,250,1)]";

        const ringClass = status === "expired"
          ? "os-card os-card--expired"
          : status === "expiring"
          ? "os-card os-card--expiring"
          : "os-card os-card--fresh";

        const avatarGrad = status === "expired"
          ? "from-accent-magenta to-rose-500"
          : status === "expiring"
          ? "from-accent-amber to-orange-500"
          : "from-accent-blue to-accent-violet";

        const days = Math.ceil((new Date(item.expiryDate) - new Date()) / 86400000);
        const expiryText = days < 0 ? `closed ${Math.abs(days)}d ago` : (days === 0 ? "closes today" : `closes in ${days}d`);

        const niceStatus = status === "fresh" ? "stable" : (status === "expiring" ? "closing" : "closed");

        const card = document.createElement("div");
        card.className = ringClass;
        card.innerHTML = `
          <div class="os-card-inner">
            <div class="flex items-start justify-between gap-3">
              <div class="flex items-center gap-3 min-w-0">
                <div class="h-10 w-10 rounded-xl bg-gradient-to-br ${avatarGrad} grid place-items-center text-white font-bold text-sm shrink-0">
                  ${eraIcon(item.category)}
                </div>
                <div class="min-w-0">
                  <h3 class="font-semibold leading-tight truncate">${escapeHtml(item.name)}</h3>
                  <p class="text-xs text-white/60 truncate">${item.category} ‚Ä¢ ${expiryText}</p>
                </div>
              </div>
              <div class="flex gap-2 items-center">
                <span class="chip ${chipClass}">${niceStatus}</span>
                <button class="text-white/40 hover:text-white/80 transition" aria-label="Remove" onclick="(${removeItem.toString()})(${item.id})">
                  <svg class="h-4 w-4" viewBox="0 0 24 24" fill="currentColor">
                    <path d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                  </svg>
                </button>
              </div>
            </div>
          </div>
        `;
        container.appendChild(card);
      }
    }

    function eraIcon(category) {
      const map = { "ancient":"üè∫","industrial":"üè≠","present":"üï∞Ô∏è","near-future":"üöÄ","far-future":"ü™ê","parallel":"‚ôæÔ∏è" };
      return map[category] || "üß≠";
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;")
        .replaceAll('"',"&quot;").replaceAll("'","&#039;");
    }

    function updateStabilityRing(freshCount, expiringCount, expiredCount) {
      const total = freshCount + expiringCount + expiredCount;
      const pct = total ? Math.round((freshCount / total) * 100) : 0;
      const ring = document.getElementById('freshnessRing');
      const pctEl = document.getElementById('freshnessPct');
      const C = 2 * Math.PI * 54;
      ring.style.strokeDasharray = C;
      ring.style.strokeDashoffset = C - (C * pct / 100);
      pctEl.textContent = pct;
    }

    /* ----------------------------
       Charts (Flux line + Jumps + Battery + Risk + Chronon)
    -----------------------------*/
    let tempChart, doorChart, batteryChart, riskChart, chrononChart;

    const COLORS = {
      blue:  "#3B82F6", blueFill:  "rgba(59,130,246,0.18)",
      violet:"#7C5CFF", violetFill:"rgba(124,92,255,0.18)",
      green: "#39D98A", greenFill: "rgba(57,217,138,0.16)",
      amber: "#FBBF24", amberFill: "rgba(251,191,36,0.16)"
    };

    const TEMP_BASE = { core: [], sink: [], noise: [], phases: [] };
    const DOOR_BASE = { values: [], phases: [] };
    let BATTERY_BASE = 78; // %
    const RISK_BASE = { 
      values: [], 
      phases: [],
      interpolationSpeed: 0.02, // How quickly the risk levels interpolate to new values
      spikeMagnitudes: [], // Tracks current spike magnitudes for each risk category
      categoryShiftTime: 0, // Time until next category shift
      activeCategory: -1, // Currently "active" risk category
      labelChangeTimer: 15, // Time until a risk label changes
      previousLabels: [] // Keeps track of recently used labels
    };
    
    const CHRONON_BASE = { 
      baseValue: 100,           // Base chronon level
      values: [],               // Historical values 
      phases: [],               // Individual phases for natural oscillation
      stabilityFactor: 1.0,     // How stable is the chronon field (lower = more chaotic)
      anomalyPoints: [],        // Points where anomalies occur
      anomalyMagnitudes: [],    // Strength of anomalies
      recoveryRate: 0.05,       // Base recovery rate
      decayRate: 0.02,          // Natural decay rate
      lastJumpTime: 0,          // Time since last jump
      systemStress: 0,          // System stress level (affects stability)
      criticalThreshold: 20,    // Critical threshold for warnings
      anomalyChance: 0.01,      // Chance of random anomaly
      stressDecayRate: 0.005    // How quickly system stress decays
    };
    
    let CHRONON_SUPPLY = 100; // % - Full chronon supply
    let JUMP_CHARGE = 0; // % - Jump charge progress
    let isJumpCharging = false;
    let isJumpReady = true; // Always allow jumping
    let chrononReplenishing = false;

    function chartBaseOptions() {
      return {
        responsive: true,
        maintainAspectRatio: false,
        interaction: { mode: "index", intersect: false },
        animation: false, // manual vertical wobble
        plugins: {
          legend: { labels: { color: "rgba(255,255,255,0.9)", boxWidth: 10, boxHeight: 10 } },
          tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${Math.round(ctx.parsed.y)}` } }
        },
        scales: {
          x: { grid: { color: "rgba(255,255,255,0.08)" }, ticks: { color: "rgba(255,255,255,0.85)", maxRotation: 0, autoSkip: true } },
          y: { grid: { color: "rgba(255,255,255,0.08)" }, ticks: { color: "rgba(255,255,255,0.85)" } }
        }
      };
    }

    function generateTempSeries() {
      const labels = [];
      const now = new Date();
      for (let i = 23; i >= 0; i--) {
        const d = new Date(now.getTime() - i * 3600000);
        const hh = d.getHours().toString().padStart(2,"0");
        labels.push(`${hh}:00`);
      }
      const core  = labels.map((_, i) => 96 + 1.2 * Math.sin(i * 0.25) + rnd(-0.6, 0.6));
      const sink  = labels.map((_, i) => 50 + 6.0 * Math.sin(i * 0.22 + 0.7) + rnd(-3, 3));
      const noise = labels.map((_, i) => 10 + 3.0 * Math.sin(i * 0.35 + 1.2) + rnd(-1.2, 1.2)); // for display only
      return { labels, core, sink, noise };
    }

    function generateJumps24h() {
      const labels = [];
      const now = new Date();
      for (let i = 23; i >= 0; i--) {
        const d = new Date(now.getTime() - i * 3600000);
        const hh = d.getHours().toString().padStart(2,"0");
        labels.push(`${hh}:00`);
      }
      const data = labels.map((_, i) => {
        const hour = (new Date(now.getTime() - (23 - i) * 3600000)).getHours();
        let base = 1 + (hour >= 7 && hour <= 9 ? 2 : 0) + (hour >= 12 && hour <= 14 ? 3 : 0) + (hour >= 18 && hour <= 21 ? 4 : 0);
        return Math.max(0, Math.round(base + rnd(-1, 1)));
      });
      return { labels, data };
    }

    function createCharts() {
      // Temporal Flux (line)
      const t = generateTempSeries();
      tempChart = new Chart(document.getElementById("tempChart").getContext("2d"), {
        type: "line",
        data: {
          labels: t.labels,
          datasets: [
            { label: "Core Stability (%)", data: t.core,  borderColor: COLORS.blue,   backgroundColor: COLORS.blueFill,   fill: true, tension: 0.35, pointRadius: 0, borderWidth: 2.25 },
            { label: "Flux Sink (index)",  data: t.sink,  borderColor: COLORS.violet, backgroundColor: COLORS.violetFill, fill: true, tension: 0.35, pointRadius: 0, borderWidth: 2.25 },
            { label: "Chrono Noise",       data: t.noise, borderColor: COLORS.green,  backgroundColor: COLORS.greenFill,  fill: true, tension: 0.35, pointRadius: 0, borderWidth: 1.75 }
          ]
        },
        options: { 
          ...chartBaseOptions(),
          scales: { 
            x: chartBaseOptions().scales.x,
            y: { ...chartBaseOptions().scales.y, suggestedMin: 0, suggestedMax: 110 }
          }
        }
      });
      TEMP_BASE.core   = t.core.slice();
      TEMP_BASE.sink   = t.sink.slice();
      TEMP_BASE.noise  = t.noise.slice();
      TEMP_BASE.phases = t.labels.map(() => Math.random() * Math.PI * 2);
      
      // Chronon Supply chart (line)
      const chrononLabels = [];
      const now = new Date();
      for (let i = 10; i >= 0; i--) {
        const d = new Date(now.getTime() - i * 3600000);
        const hh = d.getHours().toString().padStart(2,"0");
        const mm = d.getMinutes().toString().padStart(2,"0");
        chrononLabels.push(`${hh}:${mm}`);
      }
      
      // Start with full supply (100%) with some minor fluctuations
      const chrononData = chrononLabels.map(() => {
        return 100 - rnd(0, 5); // 95-100%
      });
      
      // Initialize CHRONON_BASE values
      CHRONON_BASE.values = [...chrononData];
      CHRONON_BASE.phases = chrononLabels.map(() => Math.random() * Math.PI * 2);
      CHRONON_BASE.anomalyPoints = Array(chrononLabels.length).fill(0);
      CHRONON_BASE.anomalyMagnitudes = Array(chrononLabels.length).fill(0);
      
      const chrononCtx = document.getElementById("chrononChart").getContext("2d");
      const chrononGradient = chrononCtx.createLinearGradient(0, 0, 0, 200);
      chrononGradient.addColorStop(0, COLORS.violetFill);
      chrononGradient.addColorStop(1, "rgba(99, 102, 241, 0.05)");
      
      chrononChart = new Chart(chrononCtx, {
        type: "line",
        data: {
          labels: chrononLabels,
          datasets: [
            { 
              label: "Chronon Level (%)", 
              data: chrononData,
              borderColor: COLORS.violet,
              backgroundColor: chrononGradient,
              fill: true, 
              tension: 0.4, 
              pointRadius: 2,
              borderWidth: 2.5
            }
          ]
        },
        options: { 
          ...chartBaseOptions(),
          scales: { 
            x: chartBaseOptions().scales.x,
            y: { 
              ...chartBaseOptions().scales.y, 
              suggestedMin: 0, 
              suggestedMax: 110,
              grid: {
                color: "rgba(255,255,255,0.08)",
                drawBorder: false
              }
            }
          },
          plugins: {
            ...chartBaseOptions().plugins,
            annotation: {
              annotations: {
                dangerLine: {
                  type: 'line',
                  yMin: 20,
                  yMax: 20,
                  borderColor: 'rgba(255, 84, 112, 0.5)',
                  borderWidth: 2,
                  borderDash: [6, 6]
                }
              }
            }
          }
        }
      });

      // Jump Attempts (bar)
      const d = generateJumps24h();
      doorChart = new Chart(document.getElementById("doorChart").getContext("2d"), {
        type: "bar",
        data: { 
          labels: d.labels, 
          datasets: [{ label: "Jumps", data: d.data, borderColor: COLORS.blue, backgroundColor: COLORS.blueFill, borderWidth: 1 }]
        },
        options: { 
          ...chartBaseOptions(),
          scales: { 
            x: chartBaseOptions().scales.x, 
            y: { ...chartBaseOptions().scales.y, beginAtZero: true, suggestedMax: 10 } 
          }
        }
      });
      DOOR_BASE.values = d.data.slice();
      DOOR_BASE.phases = d.labels.map(() => Math.random() * Math.PI * 2);

      // Quantum Battery (doughnut)
      const bctx = document.getElementById("batteryChart").getContext("2d");
      batteryChart = new Chart(bctx, {
        type: "doughnut",
        data: {
          labels: ["Charge", "Reserve"],
          datasets: [{
            data: [BATTERY_BASE, 100 - BATTERY_BASE],
            backgroundColor: [COLORS.blue, "rgba(255,255,255,0.08)"],
            borderWidth: 0,
            hoverOffset: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          cutout: "68%",
          plugins: {
            legend: { display: false },
            tooltip: { enabled: true }
          }
        }
      });

      // Paradox Risk (radar) with dynamic data animation
      const allPossibleRisks = [
        "Bootstrap", "Grandfather", "Causal Loops", "Information Leak", "Identity Clash",
        "Timeline Fracture", "Quantum Collapse", "Temporal Echo", "Reality Decay", "Paradox Cascade"
      ];
      
      // Randomly select 5 initial risk categories from the full list
      const riskLabels = [];
      while (riskLabels.length < 5) {
        const randomRisk = allPossibleRisks[Math.floor(Math.random() * allPossibleRisks.length)];
        if (!riskLabels.includes(randomRisk)) {
          riskLabels.push(randomRisk);
        }
      }
      
      // Generate initial risk values with more variability
      const riskValues = riskLabels.map((_, i) => 20 + 40 * Math.abs(Math.sin(i * 1.3 + 0.6)) + rnd(-10, 10));
      
      // Set up spike magnitudes (initially zero)
      RISK_BASE.spikeMagnitudes = Array(riskLabels.length).fill(0);
      
      // Initialize phase offsets for base oscillation
      RISK_BASE.phases = riskValues.map(() => Math.random() * Math.PI * 2);
      
      // Set up active category and timing
      RISK_BASE.activeCategory = Math.floor(Math.random() * riskLabels.length);
      RISK_BASE.categoryShiftTime = 5 + Math.random() * 5; // 5-10 seconds for first shift
      
      riskChart = new Chart(document.getElementById("riskChart").getContext("2d"), {
        type: "radar",
        data: {
          labels: riskLabels,
          datasets: [{
            label: "Risk",
            data: riskValues,
            borderColor: COLORS.violet,
            backgroundColor: COLORS.violetFill,
            borderWidth: 2,
            pointRadius: 3,
            pointBackgroundColor: ctx => {
              // Highlight the currently active risk category with a different color
              const index = ctx.dataIndex;
              return index === RISK_BASE.activeCategory ? '#FF5470' : COLORS.violet;
            },
            pointHoverRadius: 5,
            pointHoverBorderWidth: 2,
            pointHoverBackgroundColor: '#FF5470'
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: false,
          scales: {
            r: {
              angleLines: { color: "rgba(255,255,255,0.08)" },
              grid: { color: "rgba(255,255,255,0.08)" },
              pointLabels: { 
                color: "rgba(255,255,255,0.85)", 
                font: { size: 10 },
                callback: (label, index) => {
                  // Highlight the active risk category label
                  return index === RISK_BASE.activeCategory ? 
                    `‚òÖ ${label}` : label;
                }
              },
              ticks: { display: false, beginAtZero: true, max: 100 },
              suggestedMin: 0,
              suggestedMax: 100
            }
          },
          plugins: { 
            legend: { display: false },
            tooltip: {
              callbacks: {
                label: (ctx) => {
                  const riskLevel = Math.round(ctx.raw);
                  let riskText = riskLevel <= 25 ? "Low" :
                                 riskLevel <= 50 ? "Moderate" :
                                 riskLevel <= 75 ? "High" : "CRITICAL";
                  return `Risk Level: ${riskLevel}% (${riskText})`;
                }
              }
            }
          }
        }
      });
      
      RISK_BASE.values = riskValues.slice();
      RISK_BASE.previousLabels = [...riskLabels];
    }

    // Vertical "breathing" ‚Äî no horizontal motion
    function startVerticalWobble() {
      const reduceMotion = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (reduceMotion) return;

      let t = 0;
      let last = performance.now();
      let throttle = 0;
      let riskCheckTimer = 0; // Timer to check risk levels periodically

      const ampCore  = 1.15; // %
      const ampSink  = 3.6;  // index
      const ampNoise = 1.0;  // units
      const speed = 0.9;     // radians/second

      function frame(now) {
        const dt = (now - last) / 1000; // Delta time in seconds
        last = now;
        throttle += dt;
        t += speed * dt;
        
        // Increment risk check timer
        riskCheckTimer += dt;
        
        // Check risk levels every 3 seconds
        if (riskCheckTimer >= 3) {
          riskCheckTimer = 0;
          checkRiskLevels();
        }

        if (throttle >= 0.12) {
          throttle = 0;

          // Flux line chart
          if (tempChart) {
            const core = tempChart.data.datasets[0].data;
            const sink = tempChart.data.datasets[1].data;
            const noise = tempChart.data.datasets[2].data;

            for (let i = 0; i < core.length; i++) {
              const phase = TEMP_BASE.phases[i];
              const windowMod = 0.85 + 0.15 * Math.sin(i * 0.35);
              core[i]  = clamp(90, 100, TEMP_BASE.core[i]  + Math.sin(t + phase)      * ampCore  * windowMod);
              sink[i]  = clamp(30,  70,  TEMP_BASE.sink[i]  + Math.sin(t*0.9 + phase)  * ampSink  * windowMod * 0.85);
              noise[i] = clamp( 5,  18,  TEMP_BASE.noise[i] + Math.sin(t*1.2 + phase)  * ampNoise * windowMod * 0.9);
            }
            tempChart.update('none');

            const current = core[core.length - 1];
            document.getElementById("currentCore").textContent = `${Math.round(current)}%`;
          }

          // Jumps bar
          if (doorChart) {
            const bars = doorChart.data.datasets[0].data;
            for (let i = 0; i < bars.length; i++) {
              const base = DOOR_BASE.values[i];
              const phase = DOOR_BASE.phases[i];
              bars[i] = Math.max(0, Math.round(base * (1 + 0.05 * Math.sin(t*0.6 + phase))));
            }
            doorChart.update('none');
          }

          // Battery doughnut
          if (batteryChart) {
            const charge = 75 + 5 * Math.sin(t * 0.5) + rnd(-0.5, 0.5);
            batteryChart.data.datasets[0].data = [Math.max(0, Math.min(100, charge)), Math.max(0, 100 - charge)];
            batteryChart.update('none');
          }

          // Risk radar - animate by changing the data dynamically
          if (riskChart) {
            const data = riskChart.data.datasets[0].data;
            const labels = riskChart.data.labels;
            
            // Dynamically modify risk factors based on changing conditions--
            for (let i = 0; i < data.length; i++) {
              // Create more dynamic, unpredictable data changes
              
              // Base oscillation (keeps some consistency)
              const baseOscillation = RISK_BASE.values[i] + 15 * Math.sin(t * 1.5 + RISK_BASE.phases[i]);
              
              // Add randomized "risk spikes" that come and go
              const spikeChance = 0.03; // 3% chance per update
              const currentSpikeFactor = (RISK_BASE.spikeMagnitudes && RISK_BASE.spikeMagnitudes[i]) || 0;
              
              // Decay existing spikes
              if (currentSpikeFactor > 0) {
                RISK_BASE.spikeMagnitudes[i] = Math.max(0, currentSpikeFactor - 0.5);
              } 
              // Random chance to create new spike
              else if (Math.random() < spikeChance) {
                if (!RISK_BASE.spikeMagnitudes) RISK_BASE.spikeMagnitudes = Array(data.length).fill(0);
                RISK_BASE.spikeMagnitudes[i] = Math.random() * 25; // Random spike magnitude
              }
              
              // Occasional full category shift (major risk change in one area)
              if (!RISK_BASE.categoryShiftTime) RISK_BASE.categoryShiftTime = 0;
              if (!RISK_BASE.activeCategory) RISK_BASE.activeCategory = -1;
              
              RISK_BASE.categoryShiftTime -= dt;
              if (RISK_BASE.categoryShiftTime <= 0) {
                // Time to potentially shift focus to a new risk category
                const oldCategory = RISK_BASE.activeCategory;
                
                // Pick a new category, not the same as the old one
                let newCategory;
                do {
                  newCategory = Math.floor(Math.random() * data.length);
                } while (newCategory === oldCategory && data.length > 1);
                
                RISK_BASE.activeCategory = newCategory;
                RISK_BASE.categoryShiftTime = 3 + Math.random() * 7; // 3-10 seconds until next shift
                
                // Log the category shift for debugging (can be removed)
                console.log(`Risk focus shifted to: ${labels[newCategory]}`);
              }
              
              // Apply active category boost if this is the currently focused risk
              const categoryBoost = (i === RISK_BASE.activeCategory) ? 20 * Math.sin(t * 3) : 0;
              
              // Combine all factors to create the final data point
              const spikeFactor = (RISK_BASE.spikeMagnitudes && RISK_BASE.spikeMagnitudes[i]) || 0;
              const targetValue = clamp(5, 95, baseOscillation + spikeFactor + categoryBoost);
              const diff = targetValue - data[i];
              data[i] += diff * RISK_BASE.interpolationSpeed;
            }
            
            // Occasionally change a risk label to simulate evolving risk types
            if (!RISK_BASE.labelChangeTimer) RISK_BASE.labelChangeTimer = 20;
            RISK_BASE.labelChangeTimer -= dt;
            
            if (RISK_BASE.labelChangeTimer <= 0) {
              const possibleRisks = [
                "Bootstrap", "Grandfather", "Butterfly Effect", 
                "Causal Loops", "Information Leak", "Identity Clash",
                "Timeline Fracture", "Quantum Collapse", "Temporal Echo", 
                "Reality Decay", "Paradox Cascade"
              ];
              
              // Pick a random category to change
              const categoryToChange = Math.floor(Math.random() * labels.length);
              
              // Find a label we're not currently using
              let newLabel;
              do {
                newLabel = possibleRisks[Math.floor(Math.random() * possibleRisks.length)];
              } while (labels.includes(newLabel));
              
              // Change the label and store the old one to prevent immediate reuse
              const oldLabel = labels[categoryToChange];
              labels[categoryToChange] = newLabel;
              
              // Reset timer for next label change (10-30 seconds)
              RISK_BASE.labelChangeTimer = 10 + Math.random() * 20;
              
              // Log the label change (can be removed)
              console.log(`Risk category changed: ${oldLabel} ‚Üí ${newLabel}`);
              
              // When changing a risk category, give it a higher initial value
              data[categoryToChange] = clamp(50, 95, data[categoryToChange] + 30);
            }
            
            riskChart.update('none');
          }
          
          // Chronon chart - animate with dynamic data changes
          if (chrononChart && !chrononReplenishing) {
            const data = chrononChart.data.datasets[0].data;
            
            // Update system stress based on time since last jump
            CHRONON_BASE.lastJumpTime += dt;
            if (CHRONON_BASE.lastJumpTime > 30) { // After 30 seconds without jumping
              // System gets more stable over time without jumps
              CHRONON_BASE.stabilityFactor = Math.min(1.0, CHRONON_BASE.stabilityFactor + 0.001);
              // System stress decays over time
              CHRONON_BASE.systemStress = Math.max(0, CHRONON_BASE.systemStress - CHRONON_BASE.stressDecayRate);
            }
            
            // Natural slow decay when not replenishing (due to system inefficiencies)
            const naturalDecay = CHRONON_BASE.decayRate * dt * (1 + CHRONON_BASE.systemStress * 0.1);
            if (CHRONON_SUPPLY > 0 && !chrononReplenishing) {
              CHRONON_SUPPLY = Math.max(0, CHRONON_SUPPLY - naturalDecay);
            }
            
            // Process each data point with various effects
            for (let i = 0; i < data.length; i++) {
              // Base value with natural oscillation
              const phase = CHRONON_BASE.phases[i];
              const stability = CHRONON_BASE.stabilityFactor;
              
              // Base oscillation with varying stability
              const oscillationAmplitude = 3 * (2 - stability); // More amplitude when less stable
              const baseOscillation = CHRONON_BASE.values[i] + oscillationAmplitude * Math.sin(t * 0.8 + phase);
              
              // Add system stress effects (more chaos at higher stress)
              const stressEffect = CHRONON_BASE.systemStress * Math.sin(t * 2 + phase * 3) * 2;
              
              // Process anomalies (random temporal distortions)
              if (CHRONON_BASE.anomalyMagnitudes[i] > 0) {
                // Decay existing anomalies
                CHRONON_BASE.anomalyMagnitudes[i] = Math.max(0, CHRONON_BASE.anomalyMagnitudes[i] - 0.3);
              } 
              // Random chance to create new anomaly
              else if (Math.random() < CHRONON_BASE.anomalyChance * (1 + CHRONON_BASE.systemStress)) {
                // Higher system stress = more anomalies
                CHRONON_BASE.anomalyMagnitudes[i] = 5 + Math.random() * 15;
                
                // Show notification for significant anomalies
                if (CHRONON_BASE.anomalyMagnitudes[i] > 10 && Math.random() < 0.3) {
                  showNotification('Chronon field anomaly detected', 'warning');
                  playSound('alert');
                }
              }
              
              // Calculate total impact with all effects
              const anomalyEffect = CHRONON_BASE.anomalyMagnitudes[i] || 0;
              
              // Create the final data point (chronon level can't exceed 100%)
              const newValue = clamp(0, 100, 
                CHRONON_SUPPLY + // Current actual supply level
                (baseOscillation - CHRONON_SUPPLY) * 0.1 + // Pull toward the oscillating base
                stressEffect + // System stress causes fluctuations
                (anomalyEffect * (Math.random() > 0.5 ? -1 : 1)) // Anomalies cause spikes up or down
              );
              
              // Update the data point
              data[i] = newValue;
              
              // Store new base value (slowly follows actual level)
              CHRONON_BASE.values[i] = CHRONON_SUPPLY + (Math.random() - 0.5) * 2;
            }
            
            // Occasionally update the displayed chronon level
            if (Math.random() < 0.1) {
              document.getElementById('currentChrononLevel').textContent = `${Math.round(CHRONON_SUPPLY)}%`;
            
              // Show warning if chronon level is getting low
              if (CHRONON_SUPPLY <= CHRONON_BASE.criticalThreshold && !chrononReplenishing && Math.random() < 0.05) {
                showNotification('WARNING: Chronon supply critically low', 'warning');
              }
            }
            
            chrononChart.update('none');
          }
        }

        if (document.visibilityState !== 'hidden') {
          requestAnimationFrame(frame);
        } else {
          document.addEventListener('visibilitychange', () => {
            last = performance.now();
            requestAnimationFrame(frame);
          }, { once: true });
        }
      }
      requestAnimationFrame(frame);
    }

    function clamp(min, max, v){ return Math.max(min, Math.min(max, v)); }
    function rnd(a,b){ return a + Math.random()*(b-a); }

    /* ----------------------------
       Time Machine Control Functions
    -----------------------------*/
    // Temporal anomaly detection system
    let anomalyDetected = false;
    let coreStabilityMode = "Drift-Lock"; // Can be "Drift-Lock", "Quantum-Lock", or "Free-Float"
    let experimentalMode = false;
    let jumpInProgress = false;
    let jumpChargeInterval = null;
    let chrononReplenishInterval = null;
    let anomalyTypes = ["Bootstrap Paradox", "Grandfather Paradox", "Butterfly Effect", "Timeline Fracture", "Quantum Entanglement Loop"];
    
    // Audio effects
    const createAudio = (url) => {
      const audio = new Audio(url);
      audio.volume = 0.4;
      return audio;
    };
    
    const sfx = {
      buttonPress: createAudio("https://assets.mixkit.co/active_storage/sfx/2568/2568.wav"),
      alert: createAudio("https://assets.mixkit.co/active_storage/sfx/209/209.wav"),
      success: createAudio("https://assets.mixkit.co/active_storage/sfx/270/270.wav"),
      jumpStart: createAudio("https://assets.mixkit.co/active_storage/sfx/2307/2307.wav"),
      jumpEnd: createAudio("https://assets.mixkit.co/active_storage/sfx/780/780.wav"),
      stabilize: createAudio("https://assets.mixkit.co/active_storage/sfx/650/650.wav")
    };
    
    // Play sound with volume adjustment and error handling
    function playSound(sound) {
      try {
        if (!sound) return;
        const audio = sfx[sound];
        if (audio) {
          audio.currentTime = 0;
          audio.play().catch(err => console.log("Audio playback prevented:", err));
        }
      } catch (e) {
        console.log("Sound effect error:", e);
      }
    }
    
    // Show temporal notification
    function showNotification(message, type = "info") {
      const notifContainer = document.getElementById('notificationArea') || createNotificationArea();
      
      const notification = document.createElement('div');
      notification.className = `notification ${type}`;
      notification.innerHTML = `
        <div class="rounded-lg p-3 mb-2 animate-appear flex items-center gap-2 border ${type === 'warning' ? 'border-accent-amber/30 bg-accent-amber/10 text-accent-amber' : 
          type === 'danger' ? 'border-accent-magenta/30 bg-accent-magenta/10 text-accent-magenta' : 
          'border-accent-blue/30 bg-accent-blue/10 text-accent-blue'}">
          <span class="h-2 w-2 rounded-full ${type === 'warning' ? 'bg-accent-amber' : 
            type === 'danger' ? 'bg-accent-magenta' : 'bg-accent-blue'} animate-pulse"></span>
          ${message}
        </div>
      `;
      
      notifContainer.appendChild(notification);
      
      // Auto-remove notification after 8 seconds
      setTimeout(() => {
        notification.classList.add('animate-disappear');
        setTimeout(() => notification.remove(), 300);
      }, 8000);
    }
    
    function createNotificationArea() {
      const notifArea = document.createElement('div');
      notifArea.id = 'notificationArea';
      notifArea.className = 'fixed bottom-4 right-4 w-72 z-50 pointer-events-none';
      document.body.appendChild(notifArea);
      
      // Add animations to stylesheet
      const style = document.createElement('style');
      style.textContent = `
        @keyframes appear { from { opacity: 0; transform: translateY(1rem); } to { opacity: 1; transform: translateY(0); } }
        @keyframes disappear { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(-1rem); } }
        .animate-appear { animation: appear 0.3s ease-out forwards; }
        .animate-disappear { animation: disappear 0.3s ease-in forwards; }
      `;
      document.head.appendChild(style);
      
      return notifArea;
    }
    
    // Handle control deck button clicks
    function setupControlButtons() {
      // Get all control buttons
      const controlButtons = document.querySelectorAll('.glass button');
      
      // Add click event listener to each button
      controlButtons.forEach(button => {
        button.addEventListener('click', function() {
          playSound('buttonPress');
          
          const buttonText = this.textContent.trim();
          
          // Handle specific button actions
          switch(buttonText) {
            case 'Engage Drift-Lock':
              coreStabilityMode = "Drift-Lock";
              showNotification("Drift-Lock engaged. Core stability optimized.");
              updateCoreDisplay("Drift-Lock");
              // Improve stability in charts
              for (let i = 0; i < TEMP_BASE.core.length; i++) {
                TEMP_BASE.core[i] = clamp(95, 99, TEMP_BASE.core[i] + 3);
              }
              break;
              
            case 'Stabilize Core':
              playSound('stabilize');
              showNotification("Core stabilization sequence initiated", "info");
              stabilizeCore();
              break;
              
            case 'Prime Jump':
              if (experimentalMode) {
                showNotification("WARNING: Jump primed in experimental mode!", "warning");
              } else {
                showNotification("Jump sequence primed. Select destination window.", "info");
              }
              document.getElementById('addFoodBtn').textContent = "INITIATE JUMP";
              document.getElementById('addFoodBtn').classList.add('pulse-animation');
              break;
              
            case 'Purge Paradox':
              if (anomalyDetected) {
                playSound('success');
                anomalyDetected = false;
                showNotification("Paradox successfully purged from the system", "info");
                updateCausalityStatus("Stable");
              } else {
                showNotification("No active paradoxes detected in the system", "info");
              }
              break;
              
            case 'Recalibrate Beacons':
              showNotification("Temporal beacons recalibrating...", "info");
              setTimeout(() => {
                showNotification("Beacons recalibrated to quantum baseline", "info");
                // Redraw risk radar with lower values
                RISK_BASE.values = RISK_BASE.values.map(v => Math.max(5, v * 0.7));
              }, 3000);
              break;
              
            case 'Flux Dampeners':
              toggleFluxDampeners();
              break;
              
            case 'Boost':
              BATTERY_BASE += 15;
              BATTERY_BASE = Math.min(100, BATTERY_BASE);
              showNotification("Quantum battery boosted +15%", "info");
              break;
              
            case 'Balance':
              showNotification("Charge distribution optimized", "info");
              break;
              
            case 'Hibernate':
              BATTERY_BASE = Math.max(10, BATTERY_BASE - 5);
              showNotification("System entering low-power state", "info");
              break;
              
            case 'Auto-Mitigate':
              showNotification("Auto-mitigation protocols enabled", "info");
              // Reduce risk values gradually
              const interval = setInterval(() => {
                RISK_BASE.values = RISK_BASE.values.map(v => Math.max(5, v * 0.95));
                if (RISK_BASE.values.every(v => v < 20)) clearInterval(interval);
              }, 1000);
              break;
              
            case 'Audit Timeline':
              showNotification("Timeline audit in progress...", "info");
              setTimeout(() => {
                if (Math.random() > 0.7) {
                  triggerAnomaly();
                } else {
                  showNotification("Timeline audit complete. No anomalies detected.", "info");
                }
              }, 3000);
              break;
              
            default:
              showNotification(`${buttonText} function activated`, "info");
          }
        });
      });
      
      // Setup safety interlocks
      const experimentalCheckbox = document.querySelector('input[type="checkbox"]:nth-of-type(3)');
      experimentalCheckbox.addEventListener('change', function() {
        experimentalMode = this.checked;
        if (experimentalMode) {
          showNotification("WARNING: Experimental mode enabled. Causality protection reduced.", "warning");
        } else {
          showNotification("Experimental mode disabled. Standard safety protocols active.");
        }
      });
    }
    
    // Stabilize core function
    function stabilizeCore() {
      const coreEl = document.getElementById('currentCore');
      const origColor = coreEl.style.color;
      
      // Visual effect
      coreEl.style.color = '#39D98A';
      
      // Improve core stability in the chart data
      for (let i = 0; i < TEMP_BASE.core.length; i++) {
        TEMP_BASE.core[i] = clamp(96, 100, TEMP_BASE.core[i] + rnd(2, 5));
      }
      
      // Visual countdown
      let countdown = 3;
      const stabilizeInterval = setInterval(() => {
        if (countdown > 0) {
          showNotification(`Core stabilizing: T-${countdown}`, "info");
          countdown--;
        } else {
          clearInterval(stabilizeInterval);
          showNotification("Core stability at optimal levels", "info");
          setTimeout(() => {
            coreEl.style.color = origColor;
          }, 1000);
        }
      }, 1000);
    }
    
    // Toggle flux dampeners
    function toggleFluxDampeners() {
      const fluxDampenersActive = !document.querySelector('.flux-dampened');
      
      if (fluxDampenersActive) {
        // Enable dampeners - reduce animation amplitude
        document.body.classList.add('flux-dampened');
        showNotification("Flux dampeners engaged. Temporal oscillation reduced.");
      } else {
        // Disable dampeners - restore animation amplitude
        document.body.classList.remove('flux-dampened');
        showNotification("Flux dampeners disengaged. Temporal waves normalized.");
      }
    }
    
    // Update core display
    function updateCoreDisplay(mode) {
      const modeEl = document.querySelector('.status-panel p.text-sm.font-semibold');
      modeEl.textContent = mode;
    }
    
    // Update causality status
    function updateCausalityStatus(status) {
      const statusEl = document.querySelector('.status-panel p.text-sm.font-semibold.text-accent-green');
      statusEl.textContent = status;
      if (status !== "Stable") {
        statusEl.classList.remove('text-accent-green');
        statusEl.classList.add('text-accent-amber');
      } else {
        statusEl.classList.add('text-accent-green');
        statusEl.classList.remove('text-accent-amber');
      }
    }
    
    // Check for high risk levels and potentially trigger anomalies
    function checkRiskLevels() {
      if (anomalyDetected || !riskChart) return;
      
      const riskData = riskChart.data.datasets[0].data;
      const riskLabels = riskChart.data.labels;
      
      // Check if any risk category is extremely high
      let highestRiskIndex = -1;
      let highestRiskValue = 0;
      
      for (let i = 0; i < riskData.length; i++) {
        if (riskData[i] > highestRiskValue) {
          highestRiskValue = riskData[i];
          highestRiskIndex = i;
        }
      }
      
      // If any risk exceeds 85%, there's a chance of anomaly
      if (highestRiskValue > 85 && Math.random() < 0.7) {
        // Use the highest risk category as the anomaly type
        const anomalyType = riskLabels[highestRiskIndex];
        triggerAnomaly(anomalyType);
        
        // Further increase this specific risk
        riskData[highestRiskIndex] = 95;
      }
    }
    
    // Trigger temporal anomaly
    function triggerAnomaly(specificAnomaly) {
      if (anomalyDetected) return;
      
      anomalyDetected = true;
      playSound('alert');
      
      // Use specific anomaly if provided, otherwise pick a random one
      const anomalyType = specificAnomaly || 
                          riskChart?.data.labels[RISK_BASE.activeCategory] || 
                          anomalyTypes[Math.floor(Math.random() * anomalyTypes.length)];
                          
      showNotification(`‚ö†Ô∏è ALERT: ${anomalyType} anomaly detected!`, "danger");
      updateCausalityStatus("At Risk");
      
      // Visual effects for anomaly
      document.body.classList.add('anomaly-detected');
      
      // Make risk chart values spike, particularly for the triggering category
      if (riskChart) {
        const riskData = riskChart.data.datasets[0].data;
        const riskLabels = riskChart.data.labels;
        
        // Find the index of the anomaly in the current labels
        const anomalyIndex = riskLabels.indexOf(anomalyType);
        
        if (anomalyIndex >= 0) {
          // Spike the specific category that caused the anomaly
          riskData[anomalyIndex] = 95;
          
          // Also increase other risks, but less dramatically
          for (let i = 0; i < riskData.length; i++) {
            if (i !== anomalyIndex) {
              riskData[i] = Math.min(85, riskData[i] + rnd(10, 20));
            }
          }
        } else {
          // If we can't find the specific category, spike all risks
          for (let i = 0; i < riskData.length; i++) {
            riskData[i] = Math.min(95, riskData[i] + rnd(15, 30));
          }
        }
        
        // Update chart to show the new risk levels
        riskChart.update();
      }
      
      // Add pulse animation style if not already added
      if (!document.querySelector('style.anomaly-style')) {
        const style = document.createElement('style');
        style.className = 'anomaly-style';
        style.textContent = `
          @keyframes anomalyPulse { 
            0% { box-shadow: 0 0 0 0 rgba(251, 113, 133, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(251, 113, 133, 0); }
            100% { box-shadow: 0 0 0 0 rgba(251, 113, 133, 0); }
          }
          .anomaly-detected .glass {
            animation: anomalyPulse 2s infinite;
          }
        `;
        document.head.appendChild(style);
      }
    }
    
    // Start jump charge sequence
    function startJumpCharge() {
      if (isJumpCharging || jumpInProgress) return;
      
      const jumpChargeProgress = document.getElementById('jumpChargeProgress');
      const jumpChargeValue = document.getElementById('jumpChargeValue');
      const jumpNowBtn = document.getElementById('jumpNowBtn');
      
      isJumpCharging = true;
      JUMP_CHARGE = 0;
      isJumpReady = false;
      
      jumpChargeProgress.style.width = '0%';
      jumpChargeValue.textContent = '0%';
      jumpNowBtn.disabled = true;
      jumpNowBtn.classList.add('opacity-50', 'cursor-not-allowed');
      
      playSound('buttonPress');
      showNotification('Jump sequence charging. Please stand by...', 'info');
      
      // Start charging at random speed (3-5 seconds total)
      const chargeSpeed = 1.5 + Math.random() * 1.5; // 1.5-3% per increment
      
      jumpChargeInterval = setInterval(() => {
        JUMP_CHARGE += chargeSpeed;
        
        if (JUMP_CHARGE >= 100) {
          JUMP_CHARGE = 100;
          clearInterval(jumpChargeInterval);
          jumpChargeInterval = null;
          isJumpCharging = false;
          isJumpReady = true;
          
          // Make jump button pulse to indicate full charge
          jumpNowBtn.classList.add('animate-pulse', 'shadow-glow');
          
          playSound('success');
          showNotification('Jump charge complete. Ready for temporal displacement!', 'warning');
        }
        
        // Update UI
        jumpChargeProgress.style.width = `${JUMP_CHARGE}%`;
        jumpChargeValue.textContent = `${Math.round(JUMP_CHARGE)}%`;
      }, 50);
    }
    
    // Handle chronon supply management
    function drainChrononSupply() {
      // Always allow jumping, even if chronon is at 0
      
      // Drain chronon completely for each jump
      CHRONON_SUPPLY = 0;
      
      // Update the chart to show 0
      const data = chrononChart.data.datasets[0].data;
      for (let i = 0; i < data.length; i++) {
        data[i] = 0; // Set to 0 across the chart
      }
      chrononChart.update('none');
      
      // Update chronon display
      document.getElementById('currentChrononLevel').textContent = '0%';
      
      // Reset last jump time
      CHRONON_BASE.lastJumpTime = 0;
      
      // Start replenishing if not already doing so
      if (!chrononReplenishing) {
        startChrononReplenishment();
      }
      
      return true;
    }
    
    // Start chronon replenishment process
    function startChrononReplenishment() {
      if (chrononReplenishing) return;
      
      chrononReplenishing = true;
      
      // Show notification about recharge beginning
      showNotification('Chronon field stabilization in progress', 'info');
      playSound('stabilize');
      
      // Replenish chronon at a moderate rate
      chrononReplenishInterval = setInterval(() => {
        // Standard recovery rate for smooth animation from 0 to 100
        const recoveryRate = 0.5; // 0.5% per interval
        
        if (CHRONON_SUPPLY >= 100) {
          // Fully charged
          CHRONON_SUPPLY = 100;
          chrononReplenishing = false;
          clearInterval(chrononReplenishInterval);
          chrononReplenishInterval = null;
          
          showNotification('Chronon supply fully replenished', 'success');
          playSound('success');
        } else {
          // Add chronon at standard rate
          CHRONON_SUPPLY += recoveryRate;
          
          // Update UI and chart to show charge progress
          document.getElementById('currentChrononLevel').textContent = `${Math.round(CHRONON_SUPPLY)}%`;
          
          // Update chronon chart to show the recharging progress
          if (chrononChart) {
            const data = chrononChart.data.datasets[0].data;
            data.shift(); // Remove first point
            data.push(CHRONON_SUPPLY); // Add new point with current level
            chrononChart.update('none');
          }
        }
      }, 100);
    }
    
    // Flash the screen white 3 times
    function flashScreen() {
      const flashOverlay = document.createElement('div');
      flashOverlay.className = 'fixed inset-0 bg-white z-50 pointer-events-none flash-overlay opacity-0';
      document.body.appendChild(flashOverlay);
      
      // Add flash animation style
      const flashStyle = document.createElement('style');
      flashStyle.textContent = `
        @keyframes tripleFlash {
          0% { opacity: 0; }
          5% { opacity: 1; }
          15% { opacity: 0; }
          35% { opacity: 1; }
          45% { opacity: 0; }
          65% { opacity: 1; }
          75% { opacity: 0; }
        }
        .flash-overlay {
          animation: tripleFlash 1.5s ease-out forwards;
        }
      `;
      document.head.appendChild(flashStyle);
      
      // Remove overlay after animation
      setTimeout(() => {
        flashOverlay.remove();
      }, 1600);
    }
    
    // Simulate time jump with simple flash effect
    function initiateJump(destination) {
      if (jumpInProgress) return;
      
      // Check if we have enough chronon
      if (!drainChrononSupply()) {
        return;
      }
      
      jumpInProgress = true;
      
      // Flash the screen white 3 times
      flashScreen();
      
      // Play sound effect
      playSound('jumpStart');
      
      // Show jump notification
      showNotification(`Initiating jump to: ${destination}`, "info");
      
      // Add jump animation to body
      const jumpStyle = document.createElement('style');
      jumpStyle.textContent = `
        @keyframes timeJump {
          0% { filter: brightness(1) blur(0); }
          50% { filter: brightness(1.5) blur(10px); }
          100% { filter: brightness(1) blur(0); }
        }
        .jump-active {
          animation: timeJump 3s forwards;
        }
      `;
      document.head.appendChild(jumpStyle);
      document.body.classList.add('jump-active');
      
      // Chance of anomaly based on experimental mode
      const anomalyChance = experimentalMode ? 0.4 : 0.1;
      
      // Reset jump button and charge
      const jumpNowBtn = document.getElementById('jumpNowBtn');
      jumpNowBtn.classList.remove('animate-pulse', 'shadow-glow');
      JUMP_CHARGE = 0;
      isJumpReady = false;
      
      // Reset charge progress bar
      document.getElementById('jumpChargeProgress').style.width = '0%';
      document.getElementById('jumpChargeValue').textContent = '0%';
      
      // Add jump animation to body
      document.body.classList.add('jump-active');
      
      setTimeout(() => {
        document.body.classList.remove('jump-active');
        playSound('jumpEnd');
        
        // Chance of anomaly based on experimental mode
        const anomalyChance = experimentalMode ? 0.4 : 0.1;
        
        if (Math.random() < anomalyChance) {
          // For jumps, we'll use the currently active risk category if possible
          let jumpAnomalyType = null;
          if (riskChart && RISK_BASE.activeCategory >= 0) {
            jumpAnomalyType = riskChart.data.labels[RISK_BASE.activeCategory];
          } else {
            jumpAnomalyType = anomalyTypes[Math.floor(Math.random() * anomalyTypes.length)];
          }
          
          triggerAnomaly(jumpAnomalyType);
          showNotification(`Warning: ${jumpAnomalyType} detected after jump!`, "danger");
        } else {
          showNotification(`Jump to ${destination} successful!`, "success");
        }
        
        // Reset jump button
        document.getElementById('addFoodBtn').textContent = "Queue Jump";
        document.getElementById('addFoodBtn').classList.remove('pulse-animation');
        
        // Update jump count
        jumpCount++;
        document.getElementById("jumpAttempts").textContent = jumpCount;
        
        jumpInProgress = false;
        
        // Update charts after jump
        updateChartsAfterJump();
      }, 4000);
    }
    
    // Update charts after a jump
    function updateChartsAfterJump() {
      // Update the jump count in the door chart
      if (doorChart) {
        const jumpData = doorChart.data.datasets[0].data;
        jumpData.shift(); // Remove first bar
        jumpData.push(jumpCount); // Add new jump count
        doorChart.update();
      }
      
      // Make a small update to the risk chart
      if (riskChart) {
        const riskData = riskChart.data.datasets[0].data;
        
        // Create some moderate changes to risk levels
        for (let i = 0; i < riskData.length; i++) {
          riskData[i] = clamp(10, 90, riskData[i] + rnd(-10, 10));
        }
        
        // Update the chart
        riskChart.update();
      }
    }
    
    /* ----------------------------
       Boot ‚Äî populate with fake data
    -----------------------------*/
    document.addEventListener("DOMContentLoaded", () => {
      // Fake jump windows
      const demo = [
        { id: 1, name: "Renaissance ‚Äî Florence",            category: "ancient",      expiryDate: getDateOffset(6),  addedDate: getDateOffset(-1) },
        { id: 2, name: "Industrial Revolution ‚Äî London",    category: "industrial",   expiryDate: getDateOffset(2),  addedDate: getDateOffset(-4) },
        { id: 3, name: "Parallel-3 ‚Äî New York",             category: "parallel",     expiryDate: getDateOffset(1),  addedDate: getDateOffset(-1) },
        { id: 4, name: "Near-Future ‚Äî Lunar Gateway",       category: "near-future",  expiryDate: getDateOffset(9),  addedDate: getDateOffset(-2) },
        { id: 5, name: "Far-Future ‚Äî Proxima Outpost",      category: "far-future",   expiryDate: getDateOffset(12), addedDate: getDateOffset(-2) },
        { id: 6, name: "Present ‚Äî Calibration Marker",      category: "present",      expiryDate: getDateOffset(30), addedDate: getDateOffset(-10) },
        { id: 7, name: "Ancient ‚Äî Library of Alexandria",   category: "ancient",      expiryDate: getDateOffset(3),  addedDate: getDateOffset(-1) },
        { id: 8, name: "Industrial ‚Äî Telegraph Debut",      category: "industrial",   expiryDate: getDateOffset(-1), addedDate: getDateOffset(-5) }
      ];
      foodItems.splice(0, foodItems.length, ...demo);
      renderFoodItems();
      
      // Set up CSS for time machine effects
      const styleEl = document.createElement('style');
      styleEl.textContent = `
        .pulse-animation {
          animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
          0% { box-shadow: 0 0 0 0 rgba(124, 92, 255, 0.7); }
          70% { box-shadow: 0 0 0 10px rgba(124, 92, 255, 0); }
          100% { box-shadow: 0 0 0 0 rgba(124, 92, 255, 0); }
        }
        
        .flux-dampened .chart-wrap,
        .flux-dampened .chart-mini {
          transition: filter 0.5s ease;
          filter: saturate(0.8) brightness(0.95);
        }
        
        /* Reduced animation when flux dampeners active */
        .flux-dampened #tempChart,
        .flux-dampened #doorChart,
        .flux-dampened #batteryChart,
        .flux-dampened #riskChart {
          transition: opacity 0.5s ease;
          opacity: 0.85;
        }
      `;
      document.head.appendChild(styleEl);

      createCharts();
      startVerticalWobble();
      setupControlButtons();
      
      // Set up Jump Now button
      const jumpNowBtn = document.getElementById('jumpNowBtn');
      jumpNowBtn.addEventListener('click', () => {
        if (jumpInProgress) return; // Only prevent if already jumping
        
        // Play button press sound
        playSound('buttonPress');
        
        // Get destination from input field
        const destination = (document.getElementById('foodName').value || '').trim() || 
                          'Unknown Location';
        
        // Always allow jumping regardless of charge level
        initiateJump(destination);
      });
      
      // Set up random temporal anomalies
      const setupRandomAnomalies = () => {
        const minTime = 45000; // 45 seconds
        const maxTime = 120000; // 2 minutes
        const randomTime = minTime + Math.random() * (maxTime - minTime);
        
        // 30% chance of anomaly when timer expires
        const anomalyTimeout = setTimeout(() => {
          if (Math.random() < 0.3 && !anomalyDetected) {
            // Pick a random risk category from the current chart if possible
            let anomalyType = null;
            if (riskChart && riskChart.data.labels.length > 0) {
              const labels = riskChart.data.labels;
              anomalyType = labels[Math.floor(Math.random() * labels.length)];
            }
            triggerAnomaly(anomalyType);
          }
          setupRandomAnomalies(); // Set up next potential anomaly
        }, randomTime);
        
        // Store timeout reference in case we need to clear it
        window.anomalyTimeoutId = anomalyTimeout;
      };
      
      // Start the random anomaly system after a delay
      setTimeout(setupRandomAnomalies, 20000);
      
      // Add keyboard shortcuts for expert time travelers
      document.addEventListener('keydown', (e) => {
        // Only respond to shortcuts when holding Ctrl key
        if (!e.ctrlKey) return;
        
        switch(e.key) {
          case 's': // Ctrl+S: Stabilize
            e.preventDefault();
            playSound('stabilize');
            stabilizeCore();
            break;
            
          case 'j': // Ctrl+J: Prime Jump
            e.preventDefault();
            showNotification("Jump sequence primed with keyboard shortcut", "info");
            document.getElementById('addFoodBtn').textContent = "INITIATE JUMP";
            document.getElementById('addFoodBtn').classList.add('pulse-animation');
            break;
            
          case 'p': // Ctrl+P: Purge Paradox
            e.preventDefault();
            if (anomalyDetected) {
              playSound('success');
              anomalyDetected = false;
              showNotification("Paradox successfully purged from the system", "info");
              updateCausalityStatus("Stable");
              document.body.classList.remove('anomaly-detected');
            } else {
              showNotification("No active paradoxes detected in the system", "info");
            }
            break;
        }
      });
    });
  </script>
</body>
</html>
